from collections import defaultdict, deque
from typing import List

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        """
        DFS approach using graph coloring.
        
        Time Complexity: O(n + e) where e is number of edges (dislikes)
        Space Complexity: O(n + e) for graph and color array
        """
        # Build adjacency list
        graph = defaultdict(list)
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)
        
        # Color array: 0 = uncolored, 1 = color1, -1 = color2
        color = [0] * (n + 1)
        
        def dfs(node, c):
            """Try to color node with color c"""
            color[node] = c
            
            # Try to color all neighbors with opposite color
            for neighbor in graph[node]:
                if color[neighbor] == c:
                    # Neighbor has same color - impossible to bipartition
                    return False
                if color[neighbor] == 0:
                    # Neighbor uncolored, try to color with opposite color
                    if not dfs(neighbor, -c):
                        return False
            
            return True
        
        # Check each connected component
        for i in range(1, n + 1):
            if color[i] == 0:
                if not dfs(i, 1):
                    return False
        
        return True


class SolutionBFS:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        """
        BFS approach using graph coloring.
        
        Time Complexity: O(n + e)
        Space Complexity: O(n + e)
        """
        # Build adjacency list
        graph = defaultdict(list)
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)
        
        # Color array: 0 = uncolored, 1 = color1, -1 = color2
        color = [0] * (n + 1)
        
        def bfs(start):
            """BFS to color connected component starting from start"""
            queue = deque([start])
            color[start] = 1
            
            while queue:
                node = queue.popleft()
                
                for neighbor in graph[node]:
                    if color[neighbor] == color[node]:
                        # Same color - impossible
                        return False
                    
                    if color[neighbor] == 0:
                        # Uncolored, assign opposite color
                        color[neighbor] = -color[node]
                        queue.append(neighbor)
            
            return True
        
        # Check each connected component
        for i in range(1, n + 1):
            if color[i] == 0:
                if not bfs(i):
                    return False
        
        return True


class SolutionUnionFind:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        """
        Union-Find approach.
        For each person, maintain a 'friend group' and 'enemy group'.
        All enemies of a person should be in the same group.
        
        Time Complexity: O(n + e * α(n)) where α is inverse Ackermann
        Space Complexity: O(n)
        """
        parent = list(range(2 * n + 1))
        
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            parent[find(x)] = find(y)
        
        # Build adjacency list
        graph = defaultdict(list)
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)
        
        for person in range(1, n + 1):
            enemies = graph[person]
            
            if not enemies:
                continue
            
            # All enemies should be in same group
            # Check if person and first enemy are in same group
            if find(person) == find(enemies[0]):
                return False
            
            # Union all enemies together
            for enemy in enemies[1:]:
                # Check if person and enemy are in same group
                if find(person) == find(enemy):
                    return False
                union(enemies[0], enemy)
        
        return True


# Test cases
if __name__ == "__main__":
    sol = Solution()
    sol_bfs = SolutionBFS()
    sol_uf = SolutionUnionFind()
    
    # Test case 1
    n = 4
    dislikes = [[1,2],[1,3],[2,4]]
    print(f"Input: n = {n}, dislikes = {dislikes}")
    print(f"DFS Output: {sol.possibleBipartition(n, dislikes)}")
    print(f"BFS Output: {sol_bfs.possibleBipartition(n, dislikes)}")
    print(f"UF Output: {sol_uf.possibleBipartition(n, dislikes)}")
    print(f"Expected: True")
    print(f"Explanation: group1 [1,4], group2 [2,3]")
    print()
    
    # Test case 2
    n = 3
    dislikes = [[1,2],[1,3],[2,3]]
    print(f"Input: n = {n}, dislikes = {dislikes}")
    print(f"DFS Output: {sol.possibleBipartition(n, dislikes)}")
    print(f"BFS Output: {sol_bfs.possibleBipartition(n, dislikes)}")
    print(f"UF Output: {sol_uf.possibleBipartition(n, dislikes)}")
    print(f"Expected: False")
    print(f"Explanation: All three dislike each other, need at least 3 groups")
    print()
    
    # Test case 3
    n = 5
    dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
    print(f"Input: n = {n}, dislikes = {dislikes}")
    print(f"DFS Output: {sol.possibleBipartition(n, dislikes)}")
    print(f"BFS Output: {sol_bfs.possibleBipartition(n, dislikes)}")
    print(f"UF Output: {sol_uf.possibleBipartition(n, dislikes)}")
    print(f"Expected: False")
    print(f"Explanation: Forms an odd cycle (1-2-3-4-5-1)")
    print()
    
    # Test case 4: No dislikes
    n = 5
    dislikes = []
    print(f"Input: n = {n}, dislikes = {dislikes}")
    print(f"DFS Output: {sol.possibleBipartition(n, dislikes)}")
    print(f"Expected: True")
