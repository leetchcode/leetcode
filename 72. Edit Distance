class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        """
        Calculate minimum edit distance (Levenshtein distance) between two strings.
        
        Time Complexity: O(m * n) where m, n are lengths of word1 and word2
        Space Complexity: O(m * n) for the DP table
        """
        m, n = len(word1), len(word2)
        
        # Create DP table
        # dp[i][j] = minimum operations to convert word1[0:i] to word2[0:j]
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Base cases:
        # Converting empty string to word2[0:j] requires j insertions
        for j in range(n + 1):
            dp[0][j] = j
        
        # Converting word1[0:i] to empty string requires i deletions
        for i in range(m + 1):
            dp[i][0] = i
        
        # Fill the DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i-1] == word2[j-1]:
                    # Characters match, no operation needed
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # Take minimum of three operations:
                    # 1. Insert: dp[i][j-1] + 1
                    # 2. Delete: dp[i-1][j] + 1
                    # 3. Replace: dp[i-1][j-1] + 1
                    dp[i][j] = 1 + min(
                        dp[i][j-1],    # Insert
                        dp[i-1][j],    # Delete
                        dp[i-1][j-1]   # Replace
                    )
        
        return dp[m][n]


class SolutionSpaceOptimized:
    def minDistance(self, word1: str, word2: str) -> int:
        """
        Space-optimized version using only O(n) space.
        
        Time Complexity: O(m * n)
        Space Complexity: O(n) - only two rows needed
        """
        m, n = len(word1), len(word2)
        
        # Only need current and previous row
        prev = list(range(n + 1))
        curr = [0] * (n + 1)
        
        for i in range(1, m + 1):
            curr[0] = i  # Base case: delete i characters
            
            for j in range(1, n + 1):
                if word1[i-1] == word2[j-1]:
                    curr[j] = prev[j-1]
                else:
                    curr[j] = 1 + min(
                        curr[j-1],    # Insert
                        prev[j],      # Delete
                        prev[j-1]     # Replace
                    )
            
            # Swap rows
            prev, curr = curr, prev
        
        return prev[n]


# Test cases
if __name__ == "__main__":
    sol = Solution()
    sol_opt = SolutionSpaceOptimized()
    
    # Test case 1
    word1 = "horse"
    word2 = "ros"
    print(f"Input: word1 = '{word1}', word2 = '{word2}'")
    print(f"Output: {sol.minDistance(word1, word2)}")
    print(f"Expected: 3")
    print(f"Explanation: horse -> rorse (replace 'h' with 'r')")
    print(f"            rorse -> rose (delete 'r')")
    print(f"            rose -> ros (delete 'e')")
    print()
    
    # Test case 2
    word1 = "intention"
    word2 = "execution"
    print(f"Input: word1 = '{word1}', word2 = '{word2}'")
    print(f"Output: {sol.minDistance(word1, word2)}")
    print(f"Expected: 5")
    print()
    
    # Test case 3: Empty strings
    word1 = ""
    word2 = "abc"
    print(f"Input: word1 = '{word1}', word2 = '{word2}'")
    print(f"Output: {sol.minDistance(word1, word2)}")
    print(f"Expected: 3 (insert 3 characters)")
    print()
    
    # Test case 4: Same strings
    word1 = "same"
    word2 = "same"
    print(f"Input: word1 = '{word1}', word2 = '{word2}'")
    print(f"Output: {sol.minDistance(word1, word2)}")
    print(f"Expected: 0")
    print()
    
    # Verify space-optimized version
    print("Testing space-optimized version:")
    print(f"horse -> ros: {sol_opt.minDistance('horse', 'ros')}")
    print(f"intention -> execution: {sol_opt.minDistance('intention', 'execution')}")
