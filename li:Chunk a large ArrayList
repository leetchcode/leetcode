
public class ArrayListReshaping {
    
    /**
     * Reshape using subList (creates VIEWS - most efficient, no copying)
     * new_array[chunk_index][position_in_chunk] = old_list[chunk_index * chunkSize + position_in_chunk]
     * 
     * Example: chunkSize = 100
     *   new_array[0][0] = old_list[0]
     *   new_array[1][0] = old_list[100]
     *   new_array[1][5] = old_list[105]
     * 
     * WARNING: Returns views, not copies. Changes to chunks affect original list!
     */
    public static <T> List<List<T>> reshapeWithSubList(List<T> list, int chunkSize) {
        if (list == null || list.isEmpty() || chunkSize <= 0) {
            return new ArrayList<>();
        }
        
        int numChunks = (list.size() + chunkSize - 1) / chunkSize;
        List<List<T>> result = new ArrayList<>(numChunks);
        
        for (int chunkIdx = 0; chunkIdx < numChunks; chunkIdx++) {
            int start = chunkIdx * chunkSize;
            int end = Math.min(start + chunkSize, list.size());
            result.add(list.subList(start, end));  // Returns view, not copy
        }
        
        return result;
    }
    
    /**
     * Reshape with independent copies (safer but uses more memory)
     */
    public static <T> List<List<T>> reshapeWithCopy(List<T> list, int chunkSize) {
        if (list == null || list.isEmpty() || chunkSize <= 0) {
            return new ArrayList<>();
        }
        
        int numChunks = (list.size() + chunkSize - 1) / chunkSize;
        List<List<T>> result = new ArrayList<>(numChunks);
        
        for (int chunkIdx = 0; chunkIdx < numChunks; chunkIdx++) {
            int start = chunkIdx * chunkSize;
            int end = Math.min(start + chunkSize, list.size());
            result.add(new ArrayList<>(list.subList(start, end)));  // Creates copy
        }
        
        return result;
    }
    
    /**
     * Reshape to 2D array (primitive type friendly)
     */
    public static int[][] reshapeToArray(List<Integer> list, int chunkSize) {
        if (list == null || list.isEmpty() || chunkSize <= 0) {
            return new int[0][0];
        }
        
        int numChunks = (list.size() + chunkSize - 1) / chunkSize;
        int[][] result = new int[numChunks][];
        
        for (int chunkIdx = 0; chunkIdx < numChunks; chunkIdx++) {
            int start = chunkIdx * chunkSize;
            int end = Math.min(start + chunkSize, list.size());
            int chunkLength = end - start;
            
            result[chunkIdx] = new int[chunkLength];
            for (int i = 0; i < chunkLength; i++) {
                result[chunkIdx][i] = list.get(start + i);
            }
        }
        
        return result;
    }
    
    /**
     * Iterator that lazily creates subList views for each chunk.
     * Most memory efficient - creates views on-demand as you iterate.
     */
    public static class ChunkIterator<T> implements Iterator<List<T>> {
        private final List<T> list;
        private final int chunkSize;
        private int currentIndex;
        
        public ChunkIterator(List<T> list, int chunkSize) {
            if (list == null) {
                throw new IllegalArgumentException("List cannot be null");
            }
            if (chunkSize <= 0) {
                throw new IllegalArgumentException("Chunk size must be positive");
            }
            this.list = list;
            this.chunkSize = chunkSize;
            this.currentIndex = 0;
        }
        
        @Override
        public boolean hasNext() {
            return currentIndex < list.size();
        }
        
        @Override
        public List<T> next() {
            if (!hasNext()) {
                throw new NoSuchElementException("No more chunks");
            }
            
            int start = currentIndex;
            int end = Math.min(currentIndex + chunkSize, list.size());
            currentIndex = end;
            
            return list.subList(start, end); // Returns view
        }
        
        /**
         * Get the current chunk index (0-based).
         */
        public int getCurrentChunkIndex() {
            return (currentIndex / chunkSize) - (currentIndex > 0 ? 1 : 0);
        }
        
        /**
         * Reset iterator to beginning.
         */
        public void reset() {
            currentIndex = 0;
        }
    }
    
    /**
     * Thread-safe iterator using CopyOnWriteArrayList.
     * Safe for concurrent reads and writes, but creates a copy on each modification.
     */
    public static class CopyOnWriteChunkIterator<T> implements Iterator<List<T>> {
        private final java.util.concurrent.CopyOnWriteArrayList<T> list;
        private final int chunkSize;
        private int currentIndex;
        
        public CopyOnWriteChunkIterator(java.util.concurrent.CopyOnWriteArrayList<T> list, 
                                        int chunkSize) {
            if (list == null) {
                throw new IllegalArgumentException("List cannot be null");
            }
            if (chunkSize <= 0) {
                throw new IllegalArgumentException("Chunk size must be positive");
            }
            this.list = list;
            this.chunkSize = chunkSize;
            this.currentIndex = 0;
        }
        
        @Override
        public boolean hasNext() {
            return currentIndex < list.size();
        }
        
        @Override
        public List<T> next() {
            if (!hasNext()) {
                throw new NoSuchElementException("No more chunks");
            }
            
            int start = currentIndex;
            int end = Math.min(currentIndex + chunkSize, list.size());
            currentIndex = end;
            
            // Create a copy of the chunk for thread safety
            List<T> chunk = new ArrayList<>(end - start);
            for (int i = start; i < end; i++) {
                chunk.add(list.get(i));
            }
            return chunk;
        }
        
        public int getCurrentChunkIndex() {
            return (currentIndex / chunkSize) - (currentIndex > 0 ? 1 : 0);
        }
        
        public void reset() {
            currentIndex = 0;
        }
    }
    
    /**
     * Thread-safe reshape using CopyOnWriteArrayList.
     * Returns independent copies of chunks, safe for concurrent access.
     */
    public static <T> List<List<T>> reshapeThreadSafe(
            java.util.concurrent.CopyOnWriteArrayList<T> list, int chunkSize) {
        if (list == null || list.isEmpty() || chunkSize <= 0) {
            return new java.util.concurrent.CopyOnWriteArrayList<>();
        }
        
        int numChunks = (list.size() + chunkSize - 1) / chunkSize;
        List<List<T>> result = new java.util.concurrent.CopyOnWriteArrayList<>();
        
        for (int chunkIdx = 0; chunkIdx < numChunks; chunkIdx++) {
            int start = chunkIdx * chunkSize;
            int end = Math.min(start + chunkSize, list.size());
            
            List<T> chunk = new ArrayList<>(end - start);
            for (int i = start; i < end; i++) {
                chunk.add(list.get(i));
            }
            result.add(chunk);
        }
        
        return result;
    }
    
    /**
     * Thread-safe iterable for CopyOnWriteArrayList.
     */
    public static <T> Iterable<List<T>> chunksIterableThreadSafe(
            java.util.concurrent.CopyOnWriteArrayList<T> list, int chunkSize) {
        return () -> new CopyOnWriteChunkIterator<>(list, chunkSize);
    }
    public static <T> T get2D(List<T> list, int chunkSize, int chunkIdx, int posInChunk) {
        int actualIndex = chunkIdx * chunkSize + posInChunk;
        if (actualIndex >= list.size()) {
            throw new IndexOutOfBoundsException(
                "Index [" + chunkIdx + "][" + posInChunk + "] out of bounds"
            );
        }
        return list.get(actualIndex);
    }
    
    /**
     * Set element using 2D indexing notation on 1D list (no reshaping needed)
     */
    public static <T> void set2D(List<T> list, int chunkSize, int chunkIdx, 
                                 int posInChunk, T value) {
        int actualIndex = chunkIdx * chunkSize + posInChunk;
        if (actualIndex >= list.size()) {
            throw new IndexOutOfBoundsException(
                "Index [" + chunkIdx + "][" + posInChunk + "] out of bounds"
            );
        }
        list.set(actualIndex, value);
    }
    
    // ==================== Examples ====================
    
    public static void main(String[] args) {
        // Example 1: Reshape with subList (views)
        System.out.println("=== Example 1: Reshape with subList (Views) ===");
        List<Integer> numbers = new ArrayList<>();
        for (int i = 0; i < 250; i++) {
            numbers.add(i);
        }
        
        int chunkSize = 100;
        List<List<Integer>> reshaped = reshapeWithSubList(numbers, chunkSize);
        
        System.out.println("Original size: " + numbers.size());
        System.out.println("Chunk size: " + chunkSize);
        System.out.println("Number of chunks: " + reshaped.size());
        System.out.println();
        
        // Verify the mapping
        System.out.println("Verification:");
        System.out.println("reshaped[0][0] = " + reshaped.get(0).get(0) + 
                          " (should be " + numbers.get(0) + ")");
        System.out.println("reshaped[1][0] = " + reshaped.get(1).get(0) + 
                          " (should be " + numbers.get(100) + ")");
        System.out.println("reshaped[1][5] = " + reshaped.get(1).get(5) + 
                          " (should be " + numbers.get(105) + ")");
        System.out.println("reshaped[2][49] = " + reshaped.get(2).get(49) + 
                          " (should be " + numbers.get(249) + ")");
        System.out.println();
        
        // Show chunk sizes
        System.out.println("Chunk sizes:");
        for (int i = 0; i < reshaped.size(); i++) {
            System.out.println("  Chunk " + i + ": " + reshaped.get(i).size() + " elements");
        }
        System.out.println();
        
        // Example 2: Iterator approach (lazy evaluation)
        System.out.println("=== Example 2: ChunkIterator (Lazy) ===");
        List<Integer> iterList = new ArrayList<>();
        for (int i = 0; i < 15; i++) {
            iterList.add(i);
        }
        
        ChunkIterator<Integer> iterator = new ChunkIterator<>(iterList, 4);
        System.out.println("Original: " + iterList);
        System.out.println("Iterating through chunks:");
        
        while (iterator.hasNext()) {
            List<Integer> chunk = iterator.next();
            System.out.println("  Chunk " + iterator.getCurrentChunkIndex() + ": " + chunk);
        }
        System.out.println();
        
        // Example 2b: Enhanced for-loop with Iterable
        System.out.println("Using enhanced for-loop:");
        int chunkIdx = 0;
        for (List<Integer> chunk : chunksIterable(iterList, 4)) {
            System.out.println("  Chunk " + chunkIdx++ + ": " + chunk);
        }
        System.out.println();
        System.out.println("=== Example 2: View vs Copy Behavior ===");
        List<Integer> original = new ArrayList<>(
            Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
        );
        
        List<List<Integer>> views = reshapeWithSubList(original, 4);
        List<List<Integer>> copies = reshapeWithCopy(original, 4);
        
        System.out.println("Original: " + original);
        System.out.println("Views:    " + views);
        System.out.println("Copies:   " + copies);
        System.out.println();
        
        // Modify original
        System.out.println("Modifying original[5] = 999");
        original.set(5, 999);
        
        System.out.println("After modification:");
        System.out.println("Original: " + original);
        System.out.println("Views:    " + views + " ← CHANGED (it's a view)");
        System.out.println("Copies:   " + copies + " ← unchanged (independent copy)");
        System.out.println();
        
        // Modify through view
        System.out.println("Modifying views[0][0] = 777");
        views.get(0).set(0, 777);
        System.out.println("Original: " + original + " ← CHANGED (view affects original)");
        System.out.println("Views:    " + views);
        System.out.println();
        
        // Example 3: View vs Copy behavior
        System.out.println("=== Example 3: View vs Copy Behavior ===");
        List<Integer> original = new ArrayList<>(
            Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
        );
        
        List<List<Integer>> views = reshapeWithSubList(original, 4);
        List<List<Integer>> copies = reshapeWithCopy(original, 4);
        
        System.out.println("Original: " + original);
        System.out.println("Reshaped into chunks of 4:");
        for (int i = 0; i < views.size(); i++) {
            System.out.println("  Chunk " + i + ": " + views.get(i));
        }
        System.out.println();
        
        // Example 4: Iterator with stream-like processing
        System.out.println("=== Example 4: Iterator with Processing ===");
        List<Integer> processData = new ArrayList<>();
        for (int i = 1; i <= 20; i++) {
            processData.add(i);
        }
        
        System.out.println("Processing chunks and computing sums:");
        ChunkIterator<Integer> sumIterator = new ChunkIterator<>(processData, 5);
        while (sumIterator.hasNext()) {
            List<Integer> chunk = sumIterator.next();
            int sum = chunk.stream().mapToInt(Integer::intValue).sum();
            System.out.println("  Chunk: " + chunk + " → sum = " + sum);
        }
        System.out.println();
        
        // Example 5: Reshape to primitive 2D array
        System.out.println("=== Example 5: Reshape to int[][] ===");
        List<Integer> arrayList = new ArrayList<>(
            Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
        );
        int[][] arrayReshaped = reshapeToArray(arrayList, 4);
        System.out.println("Reshaped to 2D array:");
        for (int i = 0; i < arrayReshaped.length; i++) {
            System.out.println("  Row " + i + ": " + Arrays.toString(arrayReshaped[i]));
        }
        System.out.println();
        
        // Example 5: 2D access without reshaping
        System.out.println("=== Example 5: 2D Access Without Reshaping ===");
        List<Integer> accessList = new ArrayList<>(
            Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
        );
        System.out.println("Original list: " + accessList);
        System.out.println("Access using 2D indexing (chunk size = 4):");
        System.out.println("  get2D(list, 4, 0, 0) = " + get2D(accessList, 4, 0, 0));
        System.out.println("  get2D(list, 4, 1, 0) = " + get2D(accessList, 4, 1, 0));
        System.out.println("  get2D(list, 4, 1, 2) = " + get2D(accessList, 4, 1, 2));
        System.out.println("  get2D(list, 4, 2, 3) = " + get2D(accessList, 4, 2, 3));
        System.out.println();
        
        // Modify using 2D indexing
        System.out.println("Set element at [1][2] to 999:");
        set2D(accessList, 4, 1, 2, 999);
        System.out.println("  Result: " + accessList);
        System.out.println();
        
        // Example 6: 2D access without reshaping
        System.out.println("=== Example 6: 2D Access Without Reshaping ===");
        System.out.println("=== Example 6: String Reshaping ===");
        List<Integer> accessList = new ArrayList<>(
            Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
        );
        System.out.println("Original list: " + accessList);
        System.out.println("Access using 2D indexing (chunk size = 4):");
        System.out.println("  get2D(list, 4, 0, 0) = " + get2D(accessList, 4, 0, 0));
        System.out.println("  get2D(list, 4, 1, 0) = " + get2D(accessList, 4, 1, 0));
        System.out.println("  get2D(list, 4, 1, 2) = " + get2D(accessList, 4, 1, 2));
        System.out.println("  get2D(list, 4, 2, 3) = " + get2D(accessList, 4, 2, 3));
        System.out.println();
        
        // Modify using 2D indexing
        System.out.println("Set element at [1][2] to 999:");
        set2D(accessList, 4, 1, 2, 999);
        System.out.println("  Result: " + accessList);
        System.out.println();
        
        // Example 7: String reshaping
        System.out.println("=== Example 7: String Reshaping ===");
            Arrays.asList("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")
        );
        List<String> words = new ArrayList<>(
            Arrays.asList("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")
        );
        List<List<String>> wordChunks = reshapeWithSubList(words, 3);
        
        System.out.println("Original: " + words);
        System.out.println("Reshaped into chunks of 3:");
        for (int i = 0; i < wordChunks.size(); i++) {
            System.out.println("  Chunk " + i + ": " + wordChunks.get(i));
        }
        System.out.println();
        
        // Example 7: Processing reshaped data
        System.out.println("=== Example 7: Process Each Chunk ===");
        List<Integer> data = new ArrayList<>();
        for (int i = 1; i <= 12; i++) {
            data.add(i);
        }
        List<List<Integer>> chunks = reshapeWithSubList(data, 4);
        
        System.out.println("Original: " + data);
        System.out.println("Sum of each chunk:");
        for (int i = 0; i < chunks.size(); i++) {
            int sum = chunks.get(i).stream().mapToInt(Integer::intValue).sum();
            System.out.println("  Chunk " + i + ": " + chunks.get(i) + " → sum = " + sum);
        }
        System.out.println();
