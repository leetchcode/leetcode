import random
from typing import List

class RandomizedSet:
    """
    Data structure supporting insert, delete, and getRandom in O(1) average time.
    
    Key insight: Combine array (for random access) with hash map (for O(1) lookup)
    
    - Array: stores actual values, enables O(1) random access by index
    - HashMap: maps value → index in array, enables O(1) lookup
    
    For deletion: swap element to delete with last element, then pop
    """

    def __init__(self):
        """Initialize the data structure"""
        self.val_to_index = {}  # Maps value to its index in the array
        self.values = []        # Array storing all values

    def insert(self, val: int) -> bool:
        """
        Insert a value if not already present.
        Returns True if value was inserted, False if already exists.
        
        Time Complexity: O(1) average
        """
        if val in self.val_to_index:
            return False
        
        # Add value to end of array
        self.values.append(val)
        # Store mapping: value → index
        self.val_to_index[val] = len(self.values) - 1
        
        return True

    def remove(self, val: int) -> bool:
        """
        Remove a value if present.
        Returns True if value was removed, False if not present.
        
        Trick: Swap with last element, then pop (avoids shifting array elements)
        
        Time Complexity: O(1) average
        """
        if val not in self.val_to_index:
            return False
        
        # Get index of value to remove
        index = self.val_to_index[val]
        last_val = self.values[-1]
        
        # Swap: move last element to the position of element to remove
        self.values[index] = last_val
        self.val_to_index[last_val] = index
        
        # Remove last element (which is now the value we want to delete)
        self.values.pop()
        del self.val_to_index[val]
        
        return True

    def getRandom(self) -> int:
        """
        Get a random element from the set with uniform probability.
        
        Time Complexity: O(1)
        """
        return random.choice(self.values)


class RandomizedSetVerbose:
    """
    Same implementation with detailed comments and print statements for learning
    """

    def __init__(self):
        self.val_to_index = {}
        self.values = []
        print("Initialized RandomizedSet")
        print(f"  values: {self.values}")
        print(f"  val_to_index: {self.val_to_index}\n")

    def insert(self, val: int) -> bool:
        print(f"INSERT {val}:")
        
        if val in self.val_to_index:
            print(f"  → Already exists, return False")
            print(f"  values: {self.values}")
            print(f"  val_to_index: {self.val_to_index}\n")
            return False
        
        self.values.append(val)
        self.val_to_index[val] = len(self.values) - 1
        
        print(f"  → Added at index {len(self.values) - 1}")
        print(f"  values: {self.values}")
        print(f"  val_to_index: {self.val_to_index}\n")
        return True

    def remove(self, val: int) -> bool:
        print(f"REMOVE {val}:")
        
        if val not in self.val_to_index:
            print(f"  → Not found, return False")
            print(f"  values: {self.values}")
            print(f"  val_to_index: {self.val_to_index}\n")
            return False
        
        index = self.val_to_index[val]
        last_val = self.values[-1]
        
        print(f"  → Value {val} is at index {index}")
        print(f"  → Last value is {last_val} at index {len(self.values) - 1}")
        print(f"  → Swapping {val} with {last_val}")
        
        # Swap
        self.values[index] = last_val
        self.val_to_index[last_val] = index
        
        # Remove
        self.values.pop()
        del self.val_to_index[val]
        
        print(f"  → After removal:")
        print(f"  values: {self.values}")
        print(f"  val_to_index: {self.val_to_index}\n")
        return True

    def getRandom(self) -> int:
        result = random.choice(self.values)
        print(f"GET_RANDOM: returned {result}")
        print(f"  (randomly selected from {self.values})\n")
        return result


def test_basic_operations():
    """Test basic insert, remove, getRandom operations"""
    print("=" * 60)
    print("TEST: Basic Operations")
    print("=" * 60)
    
    rs = RandomizedSetVerbose()
    
    # Insert operations
    rs.insert(1)
    rs.insert(2)
    rs.insert(2)  # Duplicate
    rs.insert(3)
    
    # Random operations
    rs.getRandom()
    rs.getRandom()
    
    # Remove operations
    rs.remove(2)
    rs.remove(2)  # Already removed
    
    # More operations
    rs.insert(4)
    rs.getRandom()
    rs.remove(1)
    rs.getRandom()


def test_edge_cases():
    """Test edge cases"""
    print("=" * 60)
    print("TEST: Edge Cases")
    print("=" * 60)
    
    rs = RandomizedSet()
    
    # Test single element
    print("Single element test:")
    print(f"  insert(5): {rs.insert(5)}")
    print(f"  getRandom(): {rs.getRandom()}")
    print(f"  remove(5): {rs.remove(5)}")
    print(f"  insert(5): {rs.insert(5)}\n")
    
    # Test remove from beginning
    rs2 = RandomizedSet()
    print("Remove first element test:")
    rs2.insert(1)
    rs2.insert(2)
    rs2.insert(3)
    print(f"  Before: {rs2.values}")
    print(f"  remove(1): {rs2.remove(1)}")
    print(f"  After: {rs2.values}\n")


def test_distribution():
    """Test randomness distribution"""
    print("=" * 60)
    print("TEST: Random Distribution")
    print("=" * 60)
    
    rs = RandomizedSet()
    rs.insert(1)
    rs.insert(2)
    rs.insert(3)
    rs.insert(4)
    rs.insert(5)
    
    # Call getRandom many times and count frequency
    counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
    trials = 10000
    
    for _ in range(trials):
        val = rs.getRandom()
        counts[val] += 1
    
    print(f"Called getRandom() {trials} times:")
    print(f"Expected: ~{trials // 5} per value (20% each)")
    print("\nActual distribution:")
    for val, count in sorted(counts.items()):
        percentage = (count / trials) * 100
        print(f"  Value {val}: {count:5d} times ({percentage:5.2f}%)")


def test_leetcode_example():
    """Test the example from LeetCode"""
    print("=" * 60)
    print("TEST: LeetCode Example")
    print("=" * 60)
    
    commands = ["RandomizedSet", "insert", "remove", "insert", "getRandom", 
                "remove", "insert", "getRandom"]
    args = [[], [1], [2], [2], [], [1], [2], []]
    
    rs = None
    results = []
    
    for cmd, arg in zip(commands, args):
        if cmd == "RandomizedSet":
            rs = RandomizedSet()
            results.append(None)
            print(f"{cmd}()")
        elif cmd == "insert":
            result = rs.insert(arg[0])
            results.append(result)
            print(f"{cmd}({arg[0]}) → {result}")
        elif cmd == "remove":
            result = rs.remove(arg[0])
            results.append(result)
            print(f"{cmd}({arg[0]}) → {result}")
        elif cmd == "getRandom":
            result = rs.getRandom()
            results.append(result)
            print(f"{cmd}() → {result}")
    
    print(f"\nResults: {results}")
    print(f"Expected: [null, true, false, true, 1 or 2, true, false, 2]")


# Run all tests
if __name__ == "__main__":
    test_basic_operations()
    print("\n")
    test_edge_cases()
    print("\n")
    test_leetcode_example()
    print("\n")
    test_distribution()
