"""
LeetCode 671: Second Minimum Node In a Binary Tree

Problem:
Given a non-empty special binary tree consisting of nodes with non-negative values,
where each node has either zero or two children. If the node has two children,
then this node's value is the smaller value among its two children.

Find the second minimum value in the tree. If no such value exists, return -1.

Examples:
Input: root = [2,2,5,null,null,5,7]
       2
      / \
     2   5
        / \
       5   7
Output: 5

Input: root = [2,2,2]
Output: -1
"""

from typing import Optional, Set

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    """
    Approach 1: DFS with tracking minimum values
    Time: O(n), Space: O(h) where h is height
    """
    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:
        if not root:
            return -1
        
        # The root always contains the minimum value (per problem constraint)
        min_val = root.val
        
        # Find the second minimum
        def find_second_min(node):
            if not node:
                return -1
            
            # If current node value is greater than min, it's a candidate
            if node.val > min_val:
                return node.val
            
            # Otherwise, explore children
            left = find_second_min(node.left)
            right = find_second_min(node.right)
            
            # If both children returned valid values, take the smaller one
            if left != -1 and right != -1:
                return min(left, right)
            
            # If only one child returned a valid value, return it
            # If both returned -1, return -1
            return left if left != -1 else right
        
        return find_second_min(root)
    
    """
    Approach 2: Cleaner DFS with float('inf')
    Time: O(n), Space: O(h)
    """
    def findSecondMinimumValue2(self, root: Optional[TreeNode]) -> int:
        if not root:
            return -1
        
        first_min = root.val
        
        def dfs(node):
            if not node:
                return float('inf')
            
            # If we found a value greater than first minimum, it's a candidate
            if node.val > first_min:
                return node.val
            
            # Otherwise explore children and return the minimum found
            left = dfs(node.left)
            right = dfs(node.right)
            
            return min(left, right)
        
        result = dfs(root)
        return -1 if result == float('inf') else result
    
    """
    Approach 3: Iterative with Set
    Time: O(n), Space: O(n)
    """
    def findSecondMinimumValue3(self, root: Optional[TreeNode]) -> int:
        if not root:
            return -1
        
        unique_vals = set()
        
        def collect_values(node):
            if not node:
                return
            unique_vals.add(node.val)
            collect_values(node.left)
            collect_values(node.right)
        
        collect_values(root)
        
        min_val = root.val
        second_min = float('inf')
        
        for val in unique_vals:
            if min_val < val < second_min:
                second_min = val
        
        return -1 if second_min == float('inf') else second_min
    
    """
    Approach 4: One-liner using set comprehension
    Time: O(n), Space: O(n)
    """
    def findSecondMinimumValue4(self, root: Optional[TreeNode]) -> int:
        def get_all_values(node):
            if not node:
                return set()
            return {node.val} | get_all_values(node.left) | get_all_values(node.right)
        
        vals = sorted(get_all_values(root))
        return vals[1] if len(vals) >= 2 else -1


# Test cases
def test_solution():
    sol = Solution()
    
    # Test case 1: [2,2,5,null,null,5,7]
    root1 = TreeNode(2)
    root1.left = TreeNode(2)
    root1.right = TreeNode(5)
    root1.right.left = TreeNode(5)
    root1.right.right = TreeNode(7)
    print(f"Test 1: {sol.findSecondMinimumValue(root1)}")  # Expected: 5
    
    # Test case 2: [2,2,2]
    root2 = TreeNode(2)
    root2.left = TreeNode(2)
    root2.right = TreeNode(2)
    print(f"Test 2: {sol.findSecondMinimumValue(root2)}")  # Expected: -1
    
    # Test case 3: [1,1,3]
    root3 = TreeNode(1)
    root3.left = TreeNode(1)
    root3.right = TreeNode(3)
    print(f"Test 3: {sol.findSecondMinimumValue(root3)}")  # Expected: 3
    
    # Test case 4: [5,8,5]
    root4 = TreeNode(5)
    root4.left = TreeNode(8)
    root4.right = TreeNode(5)
    print(f"Test 4: {sol.findSecondMinimumValue(root4)}")  # Expected: 8
    
    # Test case 5: Single node
    root5 = TreeNode(1)
    print(f"Test 5: {sol.findSecondMinimumValue(root5)}")  # Expected: -1
    
    # Test all approaches on test case 1
    print("\nTesting all approaches:")
    print(f"Approach 1: {sol.findSecondMinimumValue(root1)}")
    print(f"Approach 2: {sol.findSecondMinimumValue2(root1)}")
    print(f"Approach 3: {sol.findSecondMinimumValue3(root1)}")
    print(f"Approach 4: {sol.findSecondMinimumValue4(root1)}")


if __name__ == "__main__":
    test_solution()


"""
Key Insights:

1. The root always contains the minimum value (per problem constraint)
   - Each parent has the minimum value of its children
   - So root is always the global minimum

2. We need to find the smallest value that's GREATER than root.val

3. Pruning optimization:
   - If a node's value > minimum, we don't need to explore its children
   - Because children will have values >= this node's value

4. Edge cases:
   - All nodes have the same value → return -1
   - Only two distinct values → return the larger one
   - Single node → return -1

Time Complexity: O(n) worst case (all nodes have minimum value)
Space Complexity: O(h) for recursion stack, where h is tree height

Approach Comparison:
- Approach 1: Most intuitive, handles -1 explicitly
- Approach 2: Cleaner using float('inf') as sentinel
- Approach 3: Simple but uses extra O(n) space for set
- Approach 4: Pythonic one-liner, good for interviews

Python-specific advantages:
- float('inf') is cleaner than Long.MAX_VALUE
- Set operations with | are concise
- Type hints with Optional make code clearer
"""
